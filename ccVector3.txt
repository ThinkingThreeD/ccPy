********************
SOURCES MATH VECTOR3
********************

-------------------------------------------------------------------------
--------------------      CROSS  ---------------------------------------
-------------------------------------------------------------------------
Maya SDK
  inline AwVector AwVector::crossProduct(const AwVector &r) const
  { return AwVector(y*r.z - z*r.y, z*r.x - x*r.z, x*r.y - y*r.x); }

Houdini SDK
  template <typename T>
  inline
  UT_Vector3T<T> cross(const UT_Vector3T<T> &v1, const UT_Vector3T<T> &v2)
  {
   // compute the cross product:
  return UT_Vector3T<T>(
  v1.y()*v2.z() - v1.z()*v2.y(),
  v1.z()*v2.x() - v1.x()*v2.z(),
  v1.x()*v2.y() - v1.y()*v2.x()
  );
  }
  
-------------------------------------------------------------------------
--------------------      DOT    ----------------------------------------
-------------------------------------------------------------------------
Maya SDK
inline double AwVector::dotProduct(const AwVector &v) const
{ return (x*v.x  + y*v.y + z*v.z); }

Houdini SDK
template <typename T>
inline
T dot(const UT_Vector3T<T> &v1, const UT_Vector3T<T> &v2)
{
return v1.x()*v2.x() + v1.y()*v2.y() + v1.z()*v2.z();
}
-------------------------------------------------------------------------
--------------------      MULTIPLY BY SCALAR    ----------------------------------------
-------------------------------------------------------------------------
Maya SDK
inline AwVector AwVector::operator*(double s) const
{ return AwVector(x * s, y * s, z * s); }

Houdini SDK
template <typename T, typename S>
inline
UT_Vector3T<T> operator*(S scalar, const UT_Vector3T<T> &v)
{
 return UT_Vector3T<T>(v.x()*scalar, v.y()*scalar, v.z()*scalar);
}

